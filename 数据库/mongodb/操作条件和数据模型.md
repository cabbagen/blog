
在 mongodb 中为应用程序建立数据模型应该考虑到数据的特点 以及 mongodb 本身的性能。 例如：不同的数据模型能够允许更有效率的查询、增加插入和更新操作的吞吐量，或者更有效地将活动分配到分片集群。

有些因素是在应用程序之外出现的操作或地址要求，但会影响基于MongoDB的应用程序的性能。在开发数据模型时，可以结合以下注意事项分析所有应用程序的读写操作。


##### 一、Document Growth （文档增长）

对于文档的更新操作可能会增加文档的大小。这些更新包括向数组中添加一个元素或者在文档中添加一个字段。   

当使用 MMAPv1 存储引擎时，文档增长可以作为数据模型的考虑因素。对于 MMAPv1 来说，如果文档大小超过了允许的空间，mongodb 将会重定位磁盘上的文档。但是，对于MongoDB 3.0.0，默认使用 [Power of 2 Sized Allocations](https://docs.mongodb.com/v3.6/core/mmapv1/#power-of-2-allocation) 可以最大限度地减少此类重新分配的发生，并允许有效重用已释放的记录空间。

当使用 MMAPv1 存储引擎时，如果你的应用程序需要频繁地进行文档增长地更新，这将导致文档增长超过[Power of 2 Sized Allocations](https://docs.mongodb.com/v3.6/core/mmapv1/#power-of-2-allocation)分配的当前功率。你可能需要参考当前的数据模型，改用
规范的数据模型，用引用来关联不同文档中的数据。

你也可以使用一个预分配策略明确的避免文档增长。参考 [Pre-Aggregated Reports Use Case](https://docs.mongodb.com/ecosystem/use-cases/pre-aggregated-reports-mmapv1/)


##### 二、Atomicity （原子性）

在 mongodb 中，文档级别的操作是原子性的。同一时间，一个写操作只能原子性的修改一个文档（因此 db.collection.updateMany() 的操作并不是原子性的）所以要确保你的应用程序将具有原子性依赖要求的所有字段存储在同一个文档中（也是由于不支持事务的原因）。如果应用程序可以允许两条数据的非原子更新，则可以将这些数据存储在单独的文档中。

在单个文档中嵌入相关数据的数据模型将有助于各种原子性操作。对于存储相关数据引用关系的数据模型，应用程序必须发出分离的读操作和写操作，去检索和修改相关的数据。参考示例：[Model Data for Atomic Operations](https://docs.mongodb.com/v3.6/tutorial/model-data-for-atomic-operations/#data-modeling-atomic-operation)

* 文档级别的原子操作包含了在单个 mongodb document 中的所有操作

* 在单个文档记录中，更新多个嵌入的相关数据，这也会是原子性的 

##### 三、Sharding （分片） 

mongodb 使用分片去提供横向的扩展。这些集群支持大数据集合高吞吐量操作的部署。分片允许用户在数据库中对集合进行分区，以将集合的文档分布到多个mongod实例或分片中。

为了在分片集合中分发数据和应用程序的流量，mongodb 使用分片键。选择正确的分片键会对性能产生重大影响，并且可以启用或阻止查询隔离并增加写入容量。仔细考虑要用作分片键的字段或字段非常重要。


##### 四、Indexs （索引）

使用索引能够提高大多数查询的性能。通常会在查询中经常出现的字段（或要依据该字段做排序）上构建索引。mongodb 默认在 _id 字段上添加了 unique 索引。
当你创建索引时，要考虑索引下面的行为：

* 每个索引至少占据 8kb 的数据空间

* 添加索引会对写操作造成一定的影响。对于有着较高的写读比的集合来说，索引是昂贵的，因为每一次插入都会更新索引

* 对于有着较高的读写比的集合来说，索引通常是有益的。索引不会影响未编制索引的读取操作

* 处于活动状态时，每个索引都会占用磁盘空间和内存。这种用法可能很重要，应该跟踪容量规划，特别是对工作集大小的关注


##### 五、Large Number of Collection （大量的集合） 

在某些情况下，你可能选择将相关信息存储在多个集合中，而不是存储在单个集合中。

通常，具有大量的集合没有显著的性能损失并且导致非常好的性能。不同的集合对于高吞吐量批处理非常重要。

当使用拥有大量集合的模型时，要考虑下面的行为：

* 每个集合都有一些几千字节的最小开销

* 每一个索引，包括 _id 索引，请求了至少 8kb 的空间

* 对于每一个数据库，一个单个命名空间文件存储了所有数据库的元数据，并且每个索引和集合在命名空间文件中都有自己的条目。mongodb 对于命名空间文件也有大小的限制 [参考](https://docs.mongodb.com/v3.6/reference/limits/#Size-of-Namespace-File)

* 使用mmapv1存储引擎的MongoDB对命名空间的数量有限制[参考](https://docs.mongodb.com/v3.6/reference/limits/#Number-of-Namespaces)。
您可能希望知道当前的命名空间数，以确定数据库可以支持多少个额外的命名空间。使用 **db.system.namespaces.count()** 命令

* 命名空间文件默认为 16M


##### 六、Collection Contains Large Number of Small Documents（集合包含大量小文档）

如果你的集合包含大量小文档，则应考虑嵌入性能原因。如果您可以通过某种逻辑关系对这些小文档进行分组，并且经常通过此分组检索文档，则可以考虑将小文档“汇总”为包含嵌入文档数组的较大文档。

将这些小的文档 **汇总（rolling up）** 成逻辑上的分组，这意味着检索一组文档将会涉及到文档的顺序读取和磁盘的随机访问。另外 重新 **汇总（rolling up）** 这些文档，并将公共字段移动到较大的文档有益于这些字段的索引。公共字段的副本将更少，并且相应索引中的关联键条目将更少。

然而，如果你经常仅仅需要在组内检索文档的子集，然后 **汇总（rolling up）**文档可能并不能提供更好的性能。此外，如果小的，单独的文档代表数据的自然模型，则应该维护该模型。


##### 七、Storage Optimization for Small Documents（对于小文档的存储优化）

每个MongoDB文档都包含一定的开销。这种开销通常是无关紧要的，但如果所有文档只是几个字节就会变得很重要，如果集合中的文档只有一个或两个字段，则可能就是这种情况。

请考虑以下建议和策略，以优化这些集合的存储利用率：

* 明确使用 _id 字段：自定 _id 字段的值，避免使用 mongodb 生成的 ObjectId（12 byte） 值

* 使用简短的字段名称：但是通常，没有必要使用短字段名称

* 使用嵌入的文档


##### 八、管理数据的生命周期（Data Lifecycle Management） 

数据建模决策应考虑数据生命周期管理。

文档的 [Time to Live or TTL feature ](https://docs.mongodb.com/v3.6/tutorial/expire-data/) 会在一段时间后使文档过期。如果您的应用程序需要一些数据在数据库中保留一段有限的时间，请考虑使用TTL功能。

此外，如果您的应用程序仅使用最近插入的文档，请考虑使用封顶集合。
