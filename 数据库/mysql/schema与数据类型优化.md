#### 一、概论

良好的逻辑设计和物理设计是高性能的基石，应该根据系统将要执行的查询语句来设计 schema，这往往需要权衡各种因素。例如，反范式的设计可以加快某些类型的查询，但同时可能使另一些类型的查询变慢。比如添加计数表和汇总表是一种很好的优化查询的方式，但这些表的维护成本可能会很高。mysql独有的特性和实现细节对性能的影响也很大。


#### 二、选择优化的数据类型

mysql 支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。

- 更小的通常更好

> 一般情况下，应该尽量使用可以正确存储数据的最小数据类型。更小的数据通常更快，因为它们占用更少的磁盘、内存和 cpu 缓存，并且处理时需要的 cpu 周期也更少，但是要确保没有低估需要存储的值的范围。

- 简单就好

> 简单数据类型的操作通常需要更少的 cpu 周期。例如，整型比字符串操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较更复杂。这里有两个例子：一个是应该使用 mysql 內建的类型而不是字符串来存储日期和时间，另外一个应该是用整型存储 IP 地址。

- 尽量避免 NULL

> 很多表都包含可为 NULL 的列，即使应用程序并不需要保存 NULL 也是如此，这是因为可为 NULL 是列的默认属性。通常情况下最好指定为 NOT NULL，除非真的需要存储 NULL 值

> 如果查询中包含可为 NULL 的列，对 mysql 来说更难优化，因为可为 NULL 的列使得索引、索引统计和值比较都更复杂。可为 NULL 的列会使用更多的存储空间，在 mysql 里也需要特殊处理。

---

##### 数字类型

> asd

#### 三、mysql schema 设计中的陷阱

- 太多的列

> mysql 的存储引擎API工作时需要在服务层和存储引擎层之间通过缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。MyISAM 的定长行结构实际上与服务器层的行结构正好匹配，所以不需要转换。然而，MyISAM 的变长行结构和 InnonDB 的行结构则总是需要转换。转换的代价依赖于列的数量。

- 太多的关联

> 所谓的 “实体-属性-值”（EAV）设计模式是个常见的糟糕设计模式，尤其在mysql 下不能靠谱的工作。一个粗略的经验法则，如果希望查询执行得快速且并发性好，单个查询最好在 12 个表以内做关联。

- 全能的枚举

> 注意防止过度使用枚举（ENUM）
````
create table ... (
    country enum('', '1', ..., '31')
)
````
> 这种 schema 的设计非常凌乱。这么使用枚举值类型也许在任何支持枚举类型的数据库都是一个有问题的设计方案，这里应该用整数作为外键关联到字典表或者查找表来查找具体的值。

- 变相的枚举

> 枚举（ENUM）列允许在列中存储一组定义值中的单个值，集合（SET）列则允许在列中存储一组定义值中的一个或多个值。有时候这可能比较容易导致混乱。
````
create table ... (
    is_default set('Y', 'N') not null default 'n',
)
````
> 如果这里真和假两种情况不会同时出现，那么毫无疑问应该使用枚举列代替集合列。

- 非此发明（Not Invent Here）的 NULL

> 之前写了避免使用 null 的好处，并且建议尽可能地考虑代替方案。即使需要存储一个事实上的“空值”到表中，也不一定非得使用 null。也许可以使用 0、某个特殊值，或者空字符串作为代替。

> 但是遵循这个原则也不要走极端。当确实需要表示未知值时也不要害怕使用 null。在一些场景中，使用 null 可能会比某个神奇常数更好。


#### 四、范式与反范式

对于任何给定的数据通常都有很多种表示方法，从完全的范式化到完全的反范式化，以及两者的折中。在范式化的数据库中，每个事实数据会出现并且只出现一次。相反，在反范式化的数据库中，信息是冗余的，可能会存储在多个地方。

##### 范式的优点和缺点

- 范式化的更新操作通常比反范式化要快

- 当数据较好地范式化时，就只要很少或者没有重复数据，所以只需要修改更少的数据

- 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快

- 很少有多余的数据意味着检索列表数据时更少需要 distinct 或者 group by 语句。

- 范式化设计的 schema 的缺点是通常需要关联。稍微复杂一些的查询语句在符合范式的 schema 上都可能需要至少一次关联，也许更多。这不但代价昂贵，也可能使一些索引策略无效。 

##### 反范式化的优点和缺点

> 反范式化的 schema 因为所有数据都在一张表中，可以很好地避免关联。

> 如果不需要关联表，则对大部分查询最差的情况——即使表没有使用索引——是全表扫描。当数据比内存大时这可能比关联要快的多，因为这样避免了随机 I/O

##### 混用范式化和反范式化

> 事实上，完全的范式化和完全的反范式化 schema 都是实验室里才有的东西：在真实世界中很少会这么极端的使用。在实际应用中经常需要混用，可能使用部分范式化的 schema、缓存表、以及其他技巧。

> 最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列。


#### 五、缓存表和汇总表

有时候提升性能最好的方法是同一张表中保存衍生的冗余数据。然而，有时也需要创建一张完全独立的汇总表或者缓存表（特别是为满足检索的需求时）。如果能容许少量的脏数据，这是非常好的方法，但是有时确实没有选择的余地（例如，需要避免复杂、昂贵的实时更新操作）

术语 “缓存表” 和 “汇总表” 没有标准的含义。我们用术语 “缓存表” 来表示存储那些可以比较简单的从 schema 其他表获取（但是每次获取的速度比较慢）数据的表（例如，逻辑上的冗余数据）。而术语 “汇总表” 时，则保存的是使用 group by 语句聚合数据的表（例如，数据不是逻辑上冗余的）。也有人使用术语 “累积表” 称呼这些表。因为这些数据被 “累积” 了 

为了提升读查询的速度，经常会需要建一些额外的索引，增加冗余列，甚至是创建缓存表和汇总表。这些方法会增加写查询的负担，也需要额外的维护任务，但在设计高性能数据库时，这些都是常见的技巧：虽然写操作变得更慢了，但更显著地提高了读操作的性能。

然而，写操作变慢并不是读操作变得更快所付出的唯一代价，还可能同时增加了读操作和写操作的开发难度。

